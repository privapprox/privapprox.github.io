<!doctype html> <html class="no-js" lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>PrivApprox Design</title> <link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/styles_feeling_responsive.css"> <script src="http://localhost:4000/assets/js/modernizr.min.js"></script> <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script> <script> WebFont.load({ google: { families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ] } }); </script> <noscript> <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic%7CVolkhov' rel='stylesheet' type='text/css'> </noscript> <!-- Search Engine Optimization --> <meta name="description" content=""> <link rel="canonical" href="http://localhost:4000/design/"> <!-- Facebook Open Graph --> <meta property="og:title" content="PrivApprox Design"> <meta property="og:description" content=""> <meta property="og:url" content="http://localhost:4000/design/"> <meta property="og:locale" content="en_EN"> <meta property="og:type" content="website"> <meta property="og:site_name" content=""> <link type="text/plain" rel="author" href="http://localhost:4000/humans.txt"> </head> <body id="top-of-page" class=""> <div id="navigation" class="sticky"> <nav class="top-bar" role="navigation" data-topbar> <ul class="title-area"> <li class="name"> <h1 class="show-for-small-only"><a href="http://localhost:4000" class="icon-tree"> </a></h1> </li> <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone --> <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li> </ul> <section class="top-bar-section"> <ul class="right"> <li class="divider"></li> <li><a href="http://localhost:4000/contact/">Contact</a></li> </ul> <ul class="left"> <li><a href="http://localhost:4000/">Home</a></li> <li class="divider"></li> <li class="active"><a href="http://localhost:4000/design/">PrivApprox Design</a></li> <li class="divider"></li> <li><a href="http://localhost:4000/benchmarks/">Micro-benchmarks</a></li> <li class="divider"></li> <li><a href="http://localhost:4000/case-studies/">Case-Studies</a></li> <li class="divider"></li> <li><a href="http://localhost:4000/proofs/">Proofs</a></li> <li class="divider"></li> </ul> </section> </nav> </div><!-- /#navigation --> <div class="row t30"> <div class="medium-12 columns"> <article> <header> <h1>PrivApprox Design</h1> </header> <div class="row"> <div class="medium-4 medium-push-8 columns"> <div class="panel radius"> <p id="toc"><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#system-overview" id="markdown-toc-system-overview">System Overview</a></li> <li><a href="#submitting-queries" id="markdown-toc-submitting-queries">Submitting Queries</a></li> <li><a href="#answering-queries" id="markdown-toc-answering-queries">Answering Queries</a> <ul> <li><a href="#step-i-sampling-at-clients" id="markdown-toc-step-i-sampling-at-clients">Step I: Sampling at Clients</a></li> <li><a href="#step-ii-answering-queries-at-clients" id="markdown-toc-step-ii-answering-queries-at-clients">Step II: Answering Queries at Clients</a></li> <li><a href="#step-iii-transmitting-answers-via-proxies" id="markdown-toc-step-iii-transmitting-answers-via-proxies">Step III: Transmitting Answers via Proxies</a></li> <li><a href="#step-iv-generating-result-at-the-aggregator" id="markdown-toc-step-iv-generating-result-at-the-aggregator">Step IV: Generating Result at the Aggregator</a></li> </ul> </li> </ul> </div> </div><!-- /.medium-4.columns --> <div class="medium-8 medium-pull-4 columns"> <h2 id="system-overview">System Overview</h2> <p>The workflow of PrivApprox consists of two main processes: submitting queries and answering queries. In the first phase, an analyst submits a query (along with the execution budget) to clients via the aggregator and proxies. In the second phase, the query is answered by the clients in the reverse direction.</p> </div><!-- /.medium-8.columns --> <div class="medium-8 medium-pull-4 columns"> <p><img class="t20" width="100%" src="http://localhost:4000/images/system-overview.png" alt="System overview" /></p> </div> <div class="medium-12 medium-pull-12 columns"> <h2 id="submitting-queries">Submitting Queries</h2> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } }, tex2jax: { inlineMath: [ ['$','$'] ], displayMath: [ ['$$','$$'] ], processEscapes: true, } }); </script> <script src="/assets/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <p>To perform statistical analysis over users’ private data streams, an analyst creates a query using the query model described in the <a href="https://arxiv.org/abs/1701.05403">technical report</a>. In particular, each query is signed by the analyst for non-repudiation and consists of the following fields:</p> <script type="math/tex; mode=display">\begin{equation} \label{eq:query} Query := \langle Q_{ID}, SQL, A[n], f, w, \delta \rangle \end{equation}</script> <ul> <li><script type="math/tex">Q_{ID}</script> denotes a unique identifier of the query. This can be generated by concatenating the identifier of the analyst with a serial number unique to the analyst.</li> <li><script type="math/tex">SQL</script> denotes the actual <script type="math/tex">SQL</script> query, which is passed on to clients and executed on their respective personal data.</li> <li><script type="math/tex">A[n]</script> denotes the format of a client’s answer to the query. The answer is an n-bit vector where each bit associates with a possible answer value in the form of a “0” or “1” per index (or answer value range). <script type="math/tex">f</script> denotes the answer frequency, i.e., how often the query needs to be executed at clients.</li> <li><script type="math/tex">w</script> denotes the window length for sliding window computations. For example, an analyst may only want to aggregate query results for the last 10 minutes, which means the window length is 10 minutes.</li> <li><script type="math/tex">\delta</script> denotes the sliding interval for sliding window computations. For example, an analyst may want to update the query results every one minute.</li> </ul> <div class="medium-12 medium-pull-12 columns"> <p><img class="t20" width="80%" src="http://localhost:4000/images/submit-query.png" alt="Submit query" /></p> </div> <p>After forming the query, the analyst sends the query, along with the query execution budget, to the aggregator. Once receiving the pair of the query and query budget from the analyst, the aggregator first converts the query budget into system parameters for sampling <script type="math/tex">(s)</script> and randomization <script type="math/tex">(p;q)</script>. Hereafter, the aggregator forwards the query and the converted system parameters to clients via proxies.</p> <h2 id="answering-queries">Answering Queries</h2> <p>The query answering process involves several steps including (i) sampling at clients for approximation; (ii) randomizing answers for privacy preservation; (iii) transmitting answers for anonymization and unlinkability; and finally, (iv) aggregating answers with error estimation to give a confidence level on the approximate output. We next explain the entire workflow using these four steps.</p> <div class="medium-12 medium-pull-12 columns"> <p><img class="t20" width="80%" src="http://localhost:4000/images/answer-query.png" alt="Answer query" /></p> </div> <h3 id="step-i-sampling-at-clients">Step I: Sampling at Clients</h3> <p>We make use of approximate computation to achieve low-latency execution by computing over a partial subset of data items instead of the entire input dataset. Our work builds on sampling-based techniques for approximate computing proposed in the context of “Big Data” analytics. Since we aim to keep the private data stored at individual clients, PrivApprox applies an input data sampling mechanism locally at the clients. In particular, we make use of <em>Simple Random Sampling (SRS)</em>.</p> <h3 id="step-ii-answering-queries-at-clients">Step II: Answering Queries at Clients</h3> <p>Next, the clients that participate in the answering process make use of randomized response to preserve privacy.</p> <p><strong>Randomized response</strong>. Randomized response protects user’s privacy by allowing individuals to answer sensitive queries without providing truthful answers all the time, yet it allows analysts to collect statistical results. Randomized response works as follow: suppose an analyst sends a query to individuals to obtain statistical data about a sensitive property. To answer the query, a client locally randomizes its answer to the query. Specifically, the client flips a coin, if it comes up heads, then the client responds its truthful answer; otherwise, the client flips a second coin and responds “Yes” if it comes up heads or “No” if it comes up tails. The privacy is preserved via the ability to refuse responding truthful answers. Suppose that the probabilities of the first coin and the second coin coming up heads are <script type="math/tex">p</script> and <script type="math/tex">q</script>, respectively. The analyst receives <script type="math/tex">N</script> randomized answers from individuals, among which <script type="math/tex">R_y</script> answers are “Yes”. Then, the number of original truthful “Yes” answers before the randomization process can be estimated as:</p> <script type="math/tex; mode=display">\begin{equation} \label{eq:estimatedAnswer} E_y = \dfrac{R_y - (1- p)\times q \times N}{p} \end{equation}</script> <p>Suppose $A_y$ and $E_y$ are the actual and the estimated numbers of the original truthful “Yes” answers, respectively. The accuracy loss $\eta$ is then defined as:</p> <script type="math/tex; mode=display">\begin{equation} \label{eq:accuracyloss} \eta = | \dfrac{A_y - E_y}{A_y} | \end{equation}</script> <p>It has been proven in~\cite{DBLP:journals/fttcs/DworkR14} that, the randomized response mechanism achieves $\epsilon$-differential privacy~\cite{differential-privacy}, where:</p> <script type="math/tex; mode=display">\begin{equation} \label{eq:privacy-level1} \varepsilon = \ln\big(\dfrac{\Pr[Response = Yes | Truth = Yes]}{\Pr[Response = Yes | Truth = No]} \big) \end{equation}</script> <p>More specifically, the randomized response mechanism achieves $\epsilon$-differential privacy, where:</p> <script type="math/tex; mode=display">\begin{equation} \label{eq:privacy-level2} \varepsilon = \ln\big(\dfrac{p + (1 - p) \times q}{(1 - p) \times q}\big) \end{equation}</script> <p>The reason is: if a truthful answer is “Yes”, then with the probability of ‘$p + (1 - p) \times q$’, the randomized answer will still remain “Yes”. Otherwise, if a truthful answer is “No”, then with the probability of ‘$(1 - p) \times q$’, the randomized answer will become “Yes”.</p> <h3 id="step-iii-transmitting-answers-via-proxies">Step III: Transmitting Answers via Proxies</h3> <p>After producing randomized responses, clients transmit them to the aggregator via the proxies. To achieve anonymity and unlinkability of the clients against the aggregator and analyst, we utilize the One-Time Pad (OTP) encryption together with source rewriting, which has been proposed for anonymous communications [cite]. Under the assumptions that:</p> <ul> <li>at least two proxies are not colluding</li> <li>the proxies don’t collude with the aggregator, nor the analyst</li> <li>the aggregator and analyst have only a local view of the network</li> </ul> <p>neither the aggregator, nor the analyst will learn any (pseudo-)identifier to deanonymize or link different answers to the same client. This property is achieved by source rewriting, which is a typical building block for anonymization schemes. At the same time the content of the answers is hidden from the proxies using OTP.</p> <p><strong>One-Time Pad (OTP) encryption.</strong> At a high-level, OTP employs extremely efficient bitwise XOR operations as its cryptographic primitive compared to expensive public-key cryptography. This allows us to support resource-constrained clients, e.g., smartphones and sensors. The underlying idea of OTP is quite simple: If Alice wants to send a secret message $M$ to Bob, then Alice and Bob share a secret one-time pad $M_K$ (in the form of a random bit-string of length $l$). To transmit the message $M$, Alice first converts $M$ into the form of bit-string of length $l$, and sends an encrypted message $M_E = M \oplus M_K$ to Bob, where $\oplus$ denotes the bit-wise XOR operation. To decrypt the message, Bob uses the bit-wise XOR operation: $M = M_E \oplus M_K$.</p> <p>Specifically, we apply OTP to transmit randomized answers as follows. At first, each randomized answer is concatenated with the associated query identifier $Q_{ID}$ to build a message $M$:</p> <script type="math/tex; mode=display">\begin{equation} \label{eq:message} M = Q_{ID}, RandomizedAnswer \end{equation}</script> <p>Thereafter, $(n-1)$ random $l$-bit key strings $M_{K_i}$ with $2 \leq i \leq n$ are generated using a cryptographic pseudo-random number generator (PRNG) seeded with a cryptographically strong random number. The XOR of all $(n-1)$ key strings together forms the pseudo one-/time pad $M_K$.</p> <script type="math/tex; mode=display">\begin{equation} M_K = \bigoplus_{i=2}^n M_{K_i} \end{equation}</script> <p>Next, it performs an XOR operation with $M$ and $M_K$ to produce an encrypted message $M_E$.</p> <script type="math/tex; mode=display">\begin{equation} M_E = M \oplus M_K \end{equation}</script> <p>As a result, the message $M$ is split into $n$ messages $\langle M_E, M_{K_2}, \cdots, M_{K_n}\rangle$. Then, a message identifier $M_{ID}$ is generated and sent together with the split messages to the $n$ proxies as follows:</p> <script type="math/tex; mode=display">\begin{equation} \label{eq:transmit} \begin{split} Client \longrightarrow Proxy1: \langle M_{ID}, M_E \rangle\\ Client \longrightarrow Proxyi: \langle M_{ID}, M_{K_i} \rangle \end{split} \end{equation}</script> <p>Upon receiving the messages (either $\langle M_{ID}, M_E \rangle$ or $\langle M_{ID}, M_{K_i} \rangle$) from clients, proxies immediately transmit the messages to the aggregator. There are two main data streams at proxies: <em>(i)</em> $\langle M_{ID}, M_E \rangle$ stream and <em>(ii)</em> $\langle M_{ID}, M_{K_i} \rangle$ stream. $M_{ID}$ is used to ensure that $M_E$ and all $M_{K_i}$ will be joined later to decrypt or rebuild the message $M$ at the aggregator. In fact, due to pseudo one-/time pad encryption being semantically secure, $\langle M_{ID}, M_E \rangle$ and all $\langle M_{ID}, M_{K_i} \rangle$ are computationally indistinguishable, which hides from the proxies if the received data stream even contains the answer $M$ or is just a pseudo-random bit string.</p> <h3 id="step-iv-generating-result-at-the-aggregator">Step IV: Generating Result at the Aggregator</h3> <p>At the aggregator, all data streams ($\langle M_{ID}, M_E \rangle$ and $\langle M_{ID}, M_{K_i} \rangle$) are received, and can be joined together to obtain a unified data stream. Specifically, the associated $M_E$ and $M_{K_i}$ are paired by using a reduce operator with the common identifier $M_{ID}$. To rebuild the original randomized message $M$ from the client, the XOR function is performed over $M_E$ and $M_K$: $M = M_E \oplus M_K$ with $M_K$ being the XOR of all $M_{K_i}$: $M_K = \bigoplus_{i=2}^n M_{K_i}$. As the aggregator does not know which of the received messages is $M_E$, it just XORs all $n$ received messages to recover $M$.</p> <p>The joined answer stream is processed to produce the query results as a sliding window computation. For each window, the aggregator first adapts the computation window to the current start time $t$ by removing all old data items, with $timestamp &lt; t$, from the window. Next, the aggregator adds the newly incoming data items into the window. Then, the answers in the window are decoded and aggregated to produce the query results for the analyst. Each query result is an estimated result which is bound to a range of error due to the approximation. The aggregator estimates this error bound and defines a confidence interval for the result as: $queryResult \pm errorBound$. The entire process is repeated for the next window, with the updated window parameters.</p> </div></div> </article> </div><!-- /.medium-12.columns --> </div><!-- /.row --> <div id="up-to-top" class="row"> <div class="small-12 columns" style="text-align: right;"> <a class="iconfont" href="#top-of-page">&#xf108;</a> </div><!-- /.small-12.columns --> </div><!-- /.row --> <footer id="footer-content" class="bg-grau"> <div id="footer"> <div class="row"> <div class="medium-6 large-5 columns"> <h5 class="shadow-black">About This Site</h5> <p class="shadow-black"> <a href="http://localhost:4000/info/">More ›</a> </p> </div><!-- /.large-6.columns --> <div class="small-6 medium-3 large-3 large-offset-1 columns"> <h5 class="shadow-black">Services</h5> <ul class="no-bullet shadow-black"> <li > <a href="http://localhost:4000" title=""></a> </li> <li > <a href="http://localhost:4000/contact/" title="Contact">Contact</a> </li> </ul> </div><!-- /.large-4.columns --> <div class="small-6 medium-3 large-3 columns"> <ul class="no-bullet shadow-black"> </ul> </div><!-- /.large-3.columns --> </div><!-- /.row --> </div><!-- /#footer --> <div id="subfooter"> <nav class="row"> <section id="subfooter-left" class="small-12 medium-6 columns credits"> </section> <section id="subfooter-right" class="small-12 medium-6 columns"> <ul class="inline-list social-icons"> <li><a href="https://bitbucket.org/lequocdo/privapprox" target="_blank" class="icon-github" title="Code for PrivApprox evaluation"></a></li> </ul> </section> </nav> </div><!-- /#subfooter --> </footer> <script src="http://localhost:4000/assets/js/javascript.min.js"></script> </body> </html>
